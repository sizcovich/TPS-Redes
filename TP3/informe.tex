\nonstopmode
\documentclass[10pt, a4paper]{article}
\parindent=20pt
\parskip=8pt
\usepackage[width=15.5cm, left=3cm, top=2.5cm, height= 24.5cm]{geometry}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{caratula}
\usepackage{epsfig}
\usepackage{pdfpages}
%\usepackage{algorithmicx}
\usepackage{lastpage}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\graphicspath{{imgs/}}

% Acomodo fancyhdr.
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Teor\'ia de las Comunicaciones}
\rhead{TP3}
\cfoot{\thepage /\pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\thesubsubsection}{\thesubsection.\alph{subsubsection}}


\author{Teor\'ia de las Comunicaciones, DC, UBA.}
\date{}
\title{}

\begin{document}
	
\thispagestyle{empty}
\materia{Teor\'ia de las Comunicaciones}
%\submateria{Trabajo Pr\'actico Nº1}
\titulo{Trabajo Práctico Nº3}
\integrante{Rivero, Maximiliano}{366/07}{maxirivero088@gmail.com}
\integrante{Izcovich, Sabrina}{550/11}{sizcovich@gmail.com}
\integrante{Rogani, Marcos}{520/05}{marcos.rogani@gmail.com}

\maketitle

\tableofcontents
\newpage

\section{Introducción}
En el siguiente trabajo práctico, ejercitamos las nociones del nivel de transporte estudiadas en la materia a través de la implementación y análisis de un protocolo sencillo: \textbf{PTC}. 

El trabajo consistió, esencialmente, en simular efectos típicos de una red (tales como pérdida de paquetes o latencia) y analizar el impacto de esto en las estimaciones del RTO de un protocolo de transporte en el contexto de una red local. 

El trabajo se dividió en dos secciones: una parte implementativa y otra en la que debimos realizar experimentos, graficar resultados y extraer conclusiones sobre lo observado.

\section{Introducción Teórica}
\begin{itemize}
\item RTO consiste en un RTT estimado definido en función de $\alpha$ y $\beta$ para un delay fijo. Cantidad de retransmisiones en función de $\alpha$ y $\beta$. Comparación entre el RTO y el RTT ``real''.\footnote{https://tools.ietf.org/html/rfc6298}

$$RTTVAR = (1 - \beta) RTTVAR + \beta |SRTT - RTT|$$
$$SRTT = (1 - \alpha)SRTT + \alpha RTT$$
$$RTO = SRTT + max(1, RTTVAR)$$

siendo SRTT (smoothed round-trip time) el RTT estimado y RTTVAR (round-trip time variation) una variación en el tiempo.
\end{itemize}

\section{Primera Parte: escenario de análisis}

En primer lugar, tomando como punto de partida el código suministrado por la cátedra, implementamos ciertas modificaciones al protocolo con el fin de generar un escenario de análisis sobre el que estudiamos qué parámetros $\alpha$, $\beta$ optimizan el cálculo del RTO\footnote{The Recovery Time Objective (RTO) is the duration of time and a service level within which a business process must be restored after a disaster in order to avoid unacceptable consequences associated with a break in continuity.}.

En primer lugar, agregamos la posibilidad de introducir un delay ($ack\_delay$) y una probabilidad $p$ de pérdida de paquetes ($ack\_loss\_probability$) al momento de enviar los ACKs. Con el fin de que fuera editable, modificamos el constructor de la clase (en el archivo $protocol.py$) para que tome el delay y la probabilidad de pérdida:
\begin{verbatim}
		def __init__(self, ack_delay=0, ack_loss_probability=0):
\end{verbatim}

Luego, modificamos la función $send\_ack$ del archivo $handler.py$ con el fin de armar el ACK para enviar una vez que llega un paquete. Para ello, agregamos lo que sigue:

\begin{verbatim}
if self.protocol.state == ESTABLISHED:
            if random.uniform(0, 1) < self.protocol.ack_loss_probability:
                print("ACKed lost segment")
                return
            if self.protocol.ack_delay > 0:
                print("Delayed ACK")
                time.sleep(self.protocol.ack_delay)
        ack_packet = self.build_packet()
        print("Sending ACK: window=%d" % ack_packet.get_window_size())
        self.socket.send(ack_packet)
\end{verbatim}
        
El primer $if$ sirve para que se aplique el delay o pérdida únicamente si se encuentra establecida la conexión.
Luego, $if random.uniform(0, 1) < self.protocol.ack_loss_probability:$ permite ver si se perdió el ACK o no, dependiendo de la probabilidad de pérdida que se le configure. En el caso en el que el paquete se pierde, realiza $return$ para terminar la función sin mandar ACK, caso contrario lo demora con $time.sleep()$, tal como se desea.

Para definir la probabilidad $p$ de pérdidad de paquetes, decidimos simularla utilizando $random.uniform(0,1)$ \footnote{docs.python.org/2/library/random.html} con el fin de que la decisión de si los paquetes fueron enviados efectivamente fuera la misma que la de ``tirar una moneda'', esto es, siguiendo una distribución uniforme.

Dado que la clase que usa PTCProtocol también debe inicializarse con los parámetros mencionados anteriormente, debimos modificar la clase $Socket$ de $ptc\_socket.py$ agregando los parámetros al constructor, siendo dicha clase la que se llama para crear un nuevo Socket. Ésto se realizó de la siguiente forma:
\begin{verbatim}
class Socket(object):
    def __init__(self, ack_delay=0, ack_loss_probability=0):
		self.protocol = PTCProtocol(ack_delay=ack_delay, ack_loss_probability=ack_loss_probability)
\end{verbatim}

\section{Segunda parte: experimentación y análisis}

En esta sección, definimos un esquema cliente-servidor en el que el cliente envía datos y el servidor se limita a reconocerlos. Para distintas combinaciones de $\alpha$ y $\beta$ debimos analizar cómo evoluciona la estimación del RTO en el cliente y buscar valores que acerquen tanto como sea posible dicha estimación al RTT ``real''. A partir de dichos resultados, analizamos cómo impactan los efectos de red simulados en los parámetros encontrados.

%%%%%%Tener en cuenta además que el protocolo mantiene la estimación en ticks, por lo que será necesario hacer la conversión a una unidad de tiempo para poder contrastarlo correctamente con el RTT.

En primer lugar, debimos realizar las modificaciones necesarias al código de forma tal que se pudieran setear los valores $\alpha$, $\beta$ y $k$. 
Para ello, modificamos el constructor de la clase $ptc\_socket$ agregándole los parámetros 
\begin{itemize}
\item alpha=0.125
\item beta=0.25
\item k=4
\end{itemize}
siendo éstos los valores por defecto de $constants.py$.

Luego, creamos una instancia del protocolo agregándole los nuevos parámetros del modo que quedara de la siguiente forma:
\begin{verbatim}
PTCProtocol(ack_delay=ack_delay, 
					ack_loss_probability=ack_loss_probability, alpha=alpha, beta=beta, k=k)
\end{verbatim}

Por otro lado, modificamos el constructor PTCProtocol para que acepte dichos parámetros de la siguiente forma:
\begin{verbatim}
def __init__(self, ack_delay=0, ack_loss_probability=0, beta, alpha, k):
\end{verbatim}

Luego, cambiamos $ALPHA$, $BETA$ y $K$ por $self.protocol.alpha$, $self.protocol.beta$ y $self.protocol.k$ respectivamente, en la función $update\_rtt\_estimation\_with$ para que dichos valores fueran los seteados desde el miembro protocolo.

Por último, creamos el cliente y servidor.

\section{Resultados}



\section{Conclusiones}


\section{Referencias}
\begin{itemize}
\item PETERSON, DAVIE ; Computer Networks, 5th edition, Wiley

\end{itemize}
\end{document}
