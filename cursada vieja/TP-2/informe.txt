3 Métodos y materiales

Con el objetivo de identificar los enlaces "transatlánticos/submarinos" se implementaron dos funcionalidades utilizando
el framework de Python[1] llamadado Scapy[1]. Ambas funciones son conocidas y se encuentran implementadas en la mayoría 
de los sistemas operativos, éstas son el comando "ping" y "traceroute".
El comando ping (Packet Internet Groper) se utiliza para diagnosticar el estado, velocidad y calidad de una red determinada, 
se basa en el envío de paquetes ICMP de solicitud y de respuesta, más precisamente del tipo "echo-request" y "echo-reply".

Más sobre el funcionamiento de los paquetes ICMP...

Función PING:

Pseudocódigo

	función ping(direccion_destino: String):
		# Creación del mensaje de petición
		# Por default el mensaje ICMP es de tipo echo-request
		mensaje_peticion <- IP(dst = direccion_destino)/ICMP()
		# Se envía el mensaje icmp por la interfaz default
		mensaje_respuesta <- enviar(mensaje_peticion)
		tiempo <- mensaje_respuesta.tiempo - mensaje_peticion.tiempo_envio
		imprimir("IP= " + mensaje_respuesta.direccion_origen + " time=" + tiempo + "ms TTL=" + mensaje_respuesta.ttl
		minimo, maximo <- mensaje_respuesta.tiempo - mensaje_peticion.tiempo_envio
		promedio <- minimo
		cant_envios <- 4
		i, cant_recibidos <- 0
		# Se mandan 3 paquetes más // for i in range(3):
		mientras (i < 3) hacer:
			mensaje_respuesta <- enviar(mensaje_peticion)
			tiempo <- mensaje_respuesta.tiempo - mensaje_peticion.tiempo_envio
			imprimir("IP= " + mensaje_respuesta.direccion_origen + " time=" + tiempo + "ms TTL=" + mensaje_respuesta.ttl
			# Calculo de estadísticas
			minimo <- si (tiempo < minimo) entonces tiempo
			maximo <- si (tiempo > maximo) entonces tiempo
			promedio <- si (mensaje_respuesta != null) entonces promedio + tiempo
			cant_recibidos <- si (mensaje_respuesta != null) entonces cant_recibidos + 1
			i <- i + 1
		# Calculo de estadísticas
		promedio <- promedio / cant_recibidos
		cant_perdidos <- cant_envios - cant_recibidos
		porcentaje_perdidos <- (cant_perdidos * 100) / cant_enviados
		imprimir("Estadisticas para " + mensaje_respuesta.direccion_origen + ":")
		imprimir("    Paquetes: Enviados = " + cant_enviados + ", Recibidos = " + cant_recibidos + 
			", Perdidos = " + cant_perdidos + "( " porcentaje_perdidos + "% perdidos),")
		imprimir("Round Trip Time aproximado en millisegundos:)
		imprimir(    "Minimo = " + minimo + "ms, Maximo = " + maximo + "ms, Promedio = " + "ms")
		
Modo de uso

Desde una consola de comandos, se realiza el llamado al script con el parámetro [1], donde [1] es la 
dirección del host de destino. El script terminará su ejecución cuando se cumpla el timeout por 
defecto (3 segundos) o cuando se reciban las respuestas de los 4 mensajes enviados, luego imprimirá por 
pantalla la información que pudo obtener de los mismos.

C:\> python.exe ping.py www.google.com

El comando tracerout es una consola de diagnóstico que permite seguir la pista de los paquetes que vienen desde un host. 
Se obtiene además una estadística del RTT o latencia de red de esos paquetes. La idea que hay detrás se basa en generar 
iterativamente el envío de un mensaje ICMP de solicitud donde en cada iteración se incrementa el campo TTL (time-to-live) 
de cada paquete IP que encapsula el pedido, inciando el ciclo desde el valor 1. Como consecuencia se logra identificar a 
los routers por donde pasan los paquetes intentando llegar al destino, revelando en cierta medida la ruta que siguen a 
través de la red, ya que se reciben las respuestas ICMP del tipo tiempo excedido (time-exceeded) que generan los routers 
intermedios al decrementar el campo TTL y verificar que la misma llegó a cero. El ciclo termina cuando el paquete finalmente 
tiene el campo TTL con el valor suficiente para llegar a destino en esa cantidad de saltos o por defecto cuando la cantidad 
de routers intermedios supere los 30.

Función TRACEROUT:

Pseudocódigo

	función tracert(direccion_destino: String, cant_saltos:int = 30):
		ttl <- 1
		destino <- null
		destino_alcanzado <- Falso
		# Mientras no llegue al destino o no supere las cantidad de saltos máximos
		mientras (!destino_alcanzado && ttl < cant_saltos) hacer:
			# Creación del mensaje de petición
			# Por default el mensaje ICMP es de tipo echo-request
			mensaje_peticion <- IP(dst = direccion_destino, ttl = ttl)/ICMP()
			# Se realizan 3 envíos
			i <- 0
			salida <- ttl
			mientras (i < 3) hacer:
				# Se envía el mensaje ICMP por la interfaz default
				mensaje_respuesta <- enviar(mensaje_peticion)
				# Si se recibe respuesta
				si (mensaje_respuesta != null) entonces:
					tiempo <- mensaje_respuesta.tiempo - mensaje_peticion.tiempo_envio
					salida <- salida + "    " + tiempo + "ms    "
					destino <- mensaje_respuesta.direccion_origen
					# Si la respuesta es un "echo-replay"
					si (mensaje_respuesta.tipo == 0) entonces:
						destino_alcanzado <- Verdadero
				si no:
					salida <- salida + "  *  "
				i <- i + 1
			# Se imprime por pantalla el resultado de los envíos y quién los generó
			si (destino_alcanzado) entonces:
				imprimir(salida + destino)
			si no:
				imprimir(salida + "Pedido fuera de tiempo")
			ttl <- ttl + 1
		imprimir("Traza completa.")

Modo de uso

Desde una consola de comandos, se realiza el llamado al script con el parámetro [1], donde [1] es la 
dirección del host de destino. El script imprimirá por pantalla a medida que vaya recibiendo las respuestas
de los routers que forman la ruta al destino y terminará su ejecución cuando finalmente el valor del TTL 
sea el suficiente como para que los mensajes lleguen al destinatario o por defecto cuando la cantidad
de saltos supere los 30 routers.

C:\> python.exe tracert.py www.google.com

WARNING: No route found for IPv6 destination :: (no default route?)
Tracing route to www.google.com [181.30.240.18]
over a maximum of 30 hops:

1       108 ms  108 ms  108 ms  181.166.144.1
2       *       *       *       Request timed out.
3       *       *       *       Request timed out.
4       *       *       *       Request timed out.
5       *       *       *       Request timed out.
6       108 ms  108 ms  109 ms  24.232.1.3
7       109 ms  108 ms  109 ms  181.30.240.18

Trace complete.

Descripción de pruebas

Los destinos seleccionados para realizar las pruebas fueron las universidades más importantes
según el ranking de la página web "Ranking Web de Universidades" (url:http://www.webometrics.info/es). 
Se eligieron países ubicados geográficamente de manera conveniente a fin de localizar los enlaces "transatlánticos/submarinos".
Para ver la disposiciones de los enlaces se utilizó la página web "Submarine Cable Map" (http://www.submarinecablemap.com) 
y en base a las conexiones que tenían los enlaces en los distintos países se seleccionaron diferentes muestras. 
Se utilizaron universidades en países de varios continentes, algunos de ellos con salida directa al océano, para favorecer 
la precisión a la hora de calcular la longitud del enlace submarino entre costa y costa.

En algunas de las muestras observamos que a fin de establecer los puntos geográficos que deberian corresponder
a el inicio y el fin del enlace "transátlantico/submarino", nos encontramos que alguno de éstos, o ambos inclusive, 
no podían ser ubicados geográficamente a través de su IP de una manera precisa para nuestro fin, que correspondería 
a una ciudad costera en el mejor de los casos. En éstos casos la IP podía ser ubicada por las herramenientas en un 
país, que en ciertos casos podría ser útil, como ser el caso de un pequeño país costero, y en otros casos podían 
llegar a ser un país como EEUU, donde considerar la muestra implicaba establecer algún punto, en principio arbitrario 
dentro de su territorio, aumentando el error cometido al calcular la distancia del enlace de la manera más precisa posible.

Existieron casos de prueba que arrojaron resultados interesantes, no en miras de localizar los enlaces, si no a fines de 
comprender como funciona la red mundial. En algunas de las universidades que teníamos como destino, la geolocalización
dió como resultado que la dirección IP pertenecía a un país distinto del país donde se encontraba la universidad.
Pensamos que en éstos cosos, la dirección IP de la universisdad podría estar hosteada en otro país o inclusive que 
el dueño de la IP resida en otro país, ya que la misma puede ser adquirida de esta manera, con lo cual a veces los destinos 
elegidos se ubicaban geográficamente en un país distinto con respecto al de donde se ubicaba la universidad de la prueba. 

Hablar de túneles y MPLS...
